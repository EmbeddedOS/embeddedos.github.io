---
title: "Inside Linux System Calls: AArch64 Implementation Explained"
description: >-
  Deep dive into Linux System Call Implementation on Aarch64.

author: Cong
date: 2025-02-16 00:01:00 +0800
categories: [Kernel, system calls]
tags: [Kernel, system calls]
image:
  path: assets/img/aarch64_kernel_booting.png
  alt: aarch64 system calls.
---

## 1. Overview

### 1.1. System Calls

In any OS, the kernel provides a set of interfaces by which processes running in userspace can interact with the system. These interfaces are called as system calls. There are three primary purposes of system calls:

- Provide an abstracted hardware for userspace. For example, when accessing a file, apps are not concerned with the type of file system on which the file resides.
- Ensure system calls ensure system security and stability. The kernel acts as a *middle man* between system resources and userspace, the kernel can arbitrate access based on permissions, users, and so on.
- A single common later between user-space and the rest of the system allows for the virtualized system provided to processes.

Without system calls, apps were free to access system resources, it would be nearly impossible to implement multitasking, virtual memory, and so more benefit features, stability and security. In Linux, system calls are the only means userspace has of interfacing with the kernel, they are the only *legal entry point* into the kernel other than exceptions and traps.

## 1.2. The system call handler

The userspace cannot execute kernel code directly, instead, the userspace must some how *signal* to the kernel that they want to execute a system call. The mechanism to signal the kernel is **a software interrupt**: Raise an exception, and the system will switch to kernel mode, and execute the exception handler. The exception handler handler, in this case, is actually the **system call handler**.

Specific system calls handler are generic for all architecture. Whereas, the *system call handler* is arch-dependent code, that is because, each architecture have its own way to handle exception, switch operation modes, registers to save and restore context, etc.

## 1.3. System calls number

Each system call is assigned a *syscall number*. This is unique number that is used to reference a specific system call. The system call handler using this number to dispatch to a corresponding system call.

### 1.4. System calls implementation on x86

The implementation on x86 are getting as examples for so many documents and resources. That is because the x86 is so popular and the implementation is quite clear to understand. Let's summarize, the x86 are using a well-known interrupt number (Normally `0x80`) to handle system call. The application makes a system call by issuing an software interrupt, the system call number and other parameters are passed via well-known registers (`EAX` register store system call number, while parameters in registers `EBX`, `ECX`, `EDX`, `ESI`, `EDI`, `EBP`).

The kernel and then handle this interrupt as a dispatcher, based on the system call number and select the corresponding system call handler. The result is also returned to well-known registers.

In this blog, we will focus on how system calls are implemented on AArch64.

## 2. Aarch64 exception

The exception model in AArch64 is a complicated topic, we only discuss basic things in here, first thing first, the concept. *Exceptions are conditions or system events* that usually require remedial action or an update of system status by privileged software to ensure smooth functioning of the system. Therefore, they can cause the currently executing program to be suspended.

> The exception concept in other architectures might be different, for example, x86, exceptions are defined as a type of interrupt that are generated by the CPU when an `error` occurs.
{: .prompt-info }

Exceptions are used for many different reasons, including the following:

- Emulating virtual devices.
- Virtual memory management.
- Handling software errors.
- Handling hardware errors.
- Handling interrupts.
- Debugging.
- *Performing calls to different privilege or security states*.
- *Handling across different Execution states*.

One of these use cases is for implementing the system call, where we can request from different privilege.

When an exception is taken, instead of moving to the next instruction, the processor stops current execution and branches to a piece of code to deal with the request. This code is know as an *exception handler*.

### 2.1. Exception level

The name for privilege in Aarch64 is Exception level, shortly, EL. The ELs are numbered, `EL<x>` with `x` between 0 and 3. The higher level of privilege the higher number.

The architecture does not specify what software uses which EL. But, a common implementation like this:

```text
ELO |        Application      |
EL1 |          Rich OS        |
EL2 |         Hypervisor      |
EL3 | Firmware/Secure Monitor |
```

The point is, who run first will have the permission to decide which one run on which level ðŸ˜›. With higher privilege, that means you have higher permission to access more memory and processor resources.

### 2.2. Exception types

There are two types of exceptions:

- Synchronous exceptions are exceptions that can be caused by the instruction that is currently executed. Different causes of synchronous exceptions:
  1. Invalid instruction and trap exceptions.
  2. Memory accesses.
  3. Exception-generating instructions.
  4. Debug exceptions.
- Asynchronous exceptions are exceptions that are generated externally, like: Interrupt, SError, IRQ and FIQ, Virtual interrupts, etc.

### 2.2. Exception generating instructions

There are instructions that intentionally cause an synchronous exception to be generated and taken. These instructions are used to implement *system call interfaces* to allow less privileged software to request services from more privileged software.

![Service call routing](assets/img/service_call_routing.png)

- The Supervisor Call (`svc`) instruction enables a user program at EL0 to request an OS service at EL1.
- The Hypervisor Call (`hvc`) instruction, enables the OS to request hypervisor services at EL2 (available of the Virtualization Extensions are implemented).
- The Secure Monitor Call (`smc`) instruction, enables the Normal world to request Secure word services from firmware at EL3 (available of the Security Extensions are implemented).

### 2.3. Exception handler

![Exception handler](assets/img/exception_handler.png)

## 3. Procedure Call Standard for AArch64

AAPCS64 defines how subroutines can be separately written, separately compiled, and separately assembled to work together. it describes a contract between a calling routine and a called routine, or between a routine and its execution environment, that defines:

- Obligations on the caller to create a program state in which the called routine may start to execute.
- Obligations on the called routine to preserve the program state of the caller across the call.
- The rights of the called routine to alter the program state of its caller.
- Obligations on all routines to preserve certain global invariants.

## 4. System call implementation

As we discussed in the previous sections, in Aarch64, the Linux kernel system calls are implemented based on the concept of exceptions. The user program that run at EL0, use `svc` instruction call to request an OS service at EL1. The kernel handles the request as the same way it handles a sync exception:

1. Save the CPU and register state.
2. Handle the Exception.
3. Restore the CPU and register state.

There is no different in steps, the main logic is centralized on exception handler, where the kernel do dispatch the system call, parsing parameter, do the specific task, and make result to user space. In this section, we will take a top-down approach, to see what happen from user request until kernel return.

### 4.1. Userspace trigger a request

User 

### 4.2. Arch code handle the system call

### 4.3. Generic code system call

## 5. Making a new system call

## 6. Debug system call
