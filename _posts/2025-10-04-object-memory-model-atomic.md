---
title: "Low latency programming: Memory model and atomic operations."
description: >-
  The most important feature in modern C++: new awareness multithreading memory model.

author: Cong
date: 2025-10-04 00:01:00 +0800
categories: [low-latency, memory-model]
tags: [low-latency, oop, memory-model, atomic, cpp]
image:
  path: assets/img/memory_model.png
  alt: memory model.
published: true
---

## Memory model

All data in c++ is made up by *objects*. The C++ standards defines an object as *a region of storage*, so whatever the object type, it's stored at one or more memory locations. Let's visualize an object into memory view.

```text
        Object in user view                         Memory location
┌──────────────────────────────────┐            ┌───────────────────────┐
│ struct my_data                   │            │           i           │
│ {                                │            ├───────────────────────┤
│   int i;                         │            │           d           │
│   double d;                      │            ├───────────────────────┤
│   unsigned bf1:10;               │            │   bf1   │    bf2      │
│   int bf2:25;                    │            ├───────────────────────┤
│   int bf3:0;                     │===========>│          bf3          │
│   int bf4:9;                     │            ├───────────────────────┤
│   int i2;                        │            │          bf4          │
│   char c1, c2;                   │            ├───────────────────────┤
│   std::string s;                 │            │           i2          │
│ };                               │            ├───────────────────────┤
└──────────────────────────────────┘            │           c1          │
                                                ├───────────────────────┤
                                                │           c2          │
                                                ├───────────────────────┤
                                                │           s           │
                                                └───────────────────────┘
```

Methods in C++ are organized in a different way, there are two types of methods: non-virtual and virtual methods. non virtual methods are treated as normal functions by the compiler:

```text
┌────────────────────┐
│ struct my_object   │
│ {                  │
│    int x;          │      ┌───────Text memory segment───────┐
│    void add(int y) │=====>│ void add(my_object *obj, int y) │
│    {               │      │ {                               │
│        x += y;     │      │       obj->x += y;              │
│    }               │      │ }                               │
│ };                 │      └─────────────────────────────────┘
└────────────────────┘
```

Meanwhile virtual methods require extra memory to look at the V-Table at runtime. The `vptr` is added to the object's memory location by the compiler automatically. It holds pointers to the actual method address.

```text
                                           Memory
                                          Location
┌──────────────────────────────────┐    ┌──────────┐    ┌Text memory segment─┐
│ struct my_object                 │===>│   vptr   │==> │ method(int y)      │
│ {                                │    ├──────────┤    │ {...}              │
│    int x;                        │    │  x(int)  │    └────────────────────┘
│    virtual void method(int y);   │    └──────────┘
│ };                               │
└──────────────────────────────────┘
```

## Memory access order

Objects are actually memory regions, so when we access the objects, we actually access memory locations. In that case, we can either do read (load) or write (store) memory. But what is the actually order those memory region can be accessed? there are some point of view about orders:

- The written code order (that's what we wrote).
- The compiler generated code order (the machine code generated by the compiler).
- And the CPU instruction execution order.

Those order can be same, or (mostly) different. Let's get some examples:

```cpp
void func(int &x, int&y)
{
    x += 1;
    y += 10;
    x += 2;
}
```

In this case, the compiler can reorder the instructions to make the code more efficient, for example it can do: `x+=3` and `y+=10` as long as the result is same. Another example:

```cpp
void func(int &x, int&y)
{
    x += 1;
    y = 10 + x;
    x += 2;
}
```

Now the compiler can't reorder statements due to the dependency of `x` in `y`. But when the CPU executes generated instructions, it can execute in different orders. One of the popular is called [out of order execution](https://en.wikipedia.org/wiki/Out-of-order_execution), in short, the CPU may execute loads/stores/ALU operations out of order to improve performance. For example:

```nasm
mov    eax, [var1]  ; [1]: load variable var1 into reg eax
inc    eax          ; [2]: eax += 1
mov    [var1], eax  ; [3]: store reg eax into var1
xor    ecx, ecx     ; [4]: ecx = 0
inc    ecx          ; [5]: ecx += 1
add    eax, ecx     ; [6]: eax = eax + ecx
```

The CPU can do step `[1]` to load the `var1`, while loading, it could issue some of the later instructions such as `[4]` and `5` too to set the `ecx`. Once step `[1]` is ready `[2]`, `[3]` and finally `[6]` will be executed. So the CPU only issues a load operation, doesn't wait, and do other task, that can avoid idling state and maximize the performance.

Those examples prove one point that the code we write can be different with the final instructions executing by the CPU. The CPU, compilers were free to reorder, cache, or optimize variables without any rules about multithreading. That's totally fine — because to your single thread, results are the same. The problems come out when we start working in multithreading, there's no general rules for compilers or CPUs to do that, and neither of them know about different threads. And we need to tell them, that's actually what C++ 11 provide: atomic operations and locking.

## Memory model in C++11
